<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grocery Price Compare</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #f5f5f0;
      --surface: #ffffff;
      --border: #ddd;
      --text: #1a1a1a;
      --text-muted: #666;
      --accent: #2563eb;
      --accent-hover: #1d4ed8;
      --green: #16a34a;
      --red: #dc2626;
      --orange: #ea580c;
      --radius: 8px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
    }

    header {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: 16px 24px;
    }

    header h1 {
      font-size: 1.25rem;
      font-weight: 700;
    }

    header p {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .app {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 24px;
      min-height: calc(100vh - 80px);
    }

    @media (max-width: 800px) {
      .app {
        grid-template-columns: 1fr;
      }
    }

    /* --- Sidebar: Controls --- */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
    }

    .card h2 {
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    /* Shopping list — lined paper */
    .shopping-list-card {
      min-height: calc((100vh - 80px) / 3);
      padding: 0;
      overflow: hidden;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .shopping-list-card h2 {
      padding: 16px 20px 0;
    }

    .lined-paper {
      --line-height: 32px;
      --margin-left: 40px;
      background:
        repeating-linear-gradient(
          to bottom,
          transparent,
          transparent calc(var(--line-height) - 1px),
          #bdd6f5 calc(var(--line-height) - 1px),
          #bdd6f5 var(--line-height)
        ),
        linear-gradient(to right, #e8bfbf 0px, #e8bfbf 2px, transparent 2px);
      background-position: 0 0, var(--margin-left) 0;
      background-size: 100% var(--line-height), 100% 100%;
      background-color: #fdf8ec;
      padding: 0 12px 0 calc(var(--margin-left) + 12px);
      flex: 1;
      overflow-y: auto;
    }

    .lined-paper-line {
      display: flex;
      align-items: center;
      height: var(--line-height);
      position: relative;
    }

    .lined-paper-line::before {
      content: "\2022";
      position: absolute;
      left: -16px;
      color: #555;
      font-size: 1rem;
      line-height: var(--line-height);
    }

    .lined-paper-line.empty::before {
      content: "";
    }

    .lined-paper-line input {
      width: 100%;
      border: none;
      background: transparent;
      font-family: 'Patrick Hand', 'Caveat', 'Segoe Print', 'Comic Sans MS', cursive;
      font-size: 0.95rem;
      color: #222;
      line-height: var(--line-height);
      height: var(--line-height);
      padding: 0;
      outline: none;
    }

    .lined-paper-line input::placeholder {
      color: #bbb;
      font-style: italic;
    }


    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: var(--radius);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s;
    }

    .btn-primary {
      background: var(--accent);
      color: #fff;
    }

    .btn-primary:hover { background: var(--accent-hover); }

    .btn-secondary {
      background: #e5e7eb;
      color: var(--text);
    }

    .btn-secondary:hover { background: #d1d5db; }

    .btn-compare {
      width: 100%;
      padding: 12px;
      font-size: 1rem;
      font-weight: 600;
    }

    .suggestions-list {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      max-height: 180px;
      overflow-y: auto;
      z-index: 100;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .suggestions-list.visible { display: block; }

    .suggestions-list div {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .suggestions-list div:hover {
      background: #f0f4ff;
    }

    .shopping-list {
      list-style: none;
      display: none;
    }

    .quick-add {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 10px 16px;
      border-top: 1px solid var(--border);
      background: var(--surface);
    }

    .quick-add button {
      padding: 4px 10px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 20px;
      background: var(--bg);
      cursor: pointer;
      color: var(--text-muted);
      transition: all 0.15s;
    }

    .quick-add button:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Location */
    .location-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .location-row input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 0.9rem;
    }

    .location-row input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
    }

    .geo-btn {
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .geo-btn:hover { background: #f0f4ff; }

    .geo-btn svg {
      width: 18px;
      height: 18px;
    }

    /* Drive time slider */
    .slider-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .slider-row input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
    }

    .slider-value {
      font-weight: 600;
      font-size: 0.9rem;
      min-width: 55px;
      text-align: right;
    }

    /* API key */
    .api-key-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 0.8rem;
      font-family: monospace;
    }

    .api-key-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.15);
    }

    .api-key-help {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 6px;
      line-height: 1.4;
    }

    .api-key-help a {
      color: var(--accent);
    }

    .api-key-status {
      font-size: 0.75rem;
      margin-top: 4px;
      font-weight: 500;
    }

    .api-key-status.valid { color: var(--green); }
    .api-key-status.missing { color: var(--orange); }

    /* --- Main: Results --- */
    .main {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    #map {
      height: 320px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      z-index: 1;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
      text-align: center;
      color: var(--text-muted);
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.4;
    }

    .empty-state p {
      font-size: 0.95rem;
    }

    /* Results table */
    .results-table-wrap {
      overflow-x: auto;
    }

    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    .results-table th,
    .results-table td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid #f0f0f0;
    }

    .results-table th {
      background: #fafafa;
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: var(--text-muted);
      position: sticky;
      top: 0;
    }

    .results-table th.store-col {
      min-width: 120px;
    }

    .results-table .cheapest {
      color: var(--green);
      font-weight: 600;
    }

    .results-table .expensive {
      color: var(--red);
      font-weight: 500;
    }

    .results-table .total-row td {
      font-weight: 700;
      border-top: 2px solid var(--text);
      font-size: 0.95rem;
    }

    .store-header {
      display: flex;
      flex-direction: column;
    }

    .store-header .store-name {
      font-weight: 600;
    }

    .store-header .store-dist {
      font-weight: 400;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: none;
      letter-spacing: 0;
    }

    .savings-banner {
      background: #f0fdf4;
      border: 1px solid #bbf7d0;
      border-radius: var(--radius);
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .savings-banner .label {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .savings-banner .value {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--green);
    }

    .savings-banner .detail {
      font-size: 0.85rem;
      color: var(--text-muted);
      text-align: right;
    }

    .no-price {
      color: #aaa;
      font-style: italic;
    }

    .location-status {
      font-size: 0.8rem;
      color: var(--green);
      margin-top: 4px;
    }

    .location-status.error {
      color: var(--red);
    }

    /* Drive-time polygon legend */
    .drive-time-legend {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .drive-time-legend .swatch {
      width: 14px;
      height: 14px;
      background: rgba(37, 99, 235, 0.12);
      border: 2px solid rgba(37, 99, 235, 0.5);
      border-radius: 3px;
      display: inline-block;
    }
  </style>
</head>
<body>
  <header>
    <h1>Grocery Price Compare</h1>
    <p>Find the cheapest groceries near you &mdash; powered by Esri</p>
  </header>

  <div class="app">
    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Shopping List -->
      <div class="card shopping-list-card">
        <h2>Shopping List</h2>
        <div class="lined-paper" id="linedPaper"></div>
        <div class="suggestions-list" id="suggestionsList"></div>
        <ul class="shopping-list" id="shoppingList"></ul>
        <div class="quick-add" id="quickAdd"></div>
      </div>

      <!-- API Key (hidden) -->
      <div class="card" style="display:none;">
        <h2>Esri API Key</h2>
        <input type="password" class="api-key-input" id="apiKeyInput" placeholder="Paste your ArcGIS API key" value="AAPTxy8BH1VEsoebNVZXo8HurPFlEj33bQWHhAhJDlfe7YinzP_b_-Kyd4takDZXk8jLiwJRH6QyVcrNZw2evjBEgXqVoIpTGlLQNrcb2QjM3OhItGer4OKJ6ZOcNfV_ltjMhybjeqrhW6546pFMLkBDiWFWVex6YenT1T5AdF2F2Ek8sG0r3V3R2eRw7BwyH1228TX-ru6RkrYF9D3uduRCGb-QY7YmIcm7zPvlepwBjGs.AT1_w4T35sfT" />
        <div class="api-key-help">
          Get a free key at <a href="https://developers.arcgis.com/sign-up/" target="_blank" rel="noopener">developers.arcgis.com</a>.<br>
          Enables geocoding and drive-time areas.
        </div>
        <div class="api-key-status valid" id="apiKeyStatus">Key set &mdash; geocoding and drive-time areas enabled</div>
      </div>

      <!-- Location -->
      <div class="card">
        <h2>Your Location</h2>
        <div class="location-row">
          <input type="text" id="locationInput" placeholder="Address or zip code" value="Hoboken, NJ" />
          <button class="geo-btn" id="geoBtn" title="Use my location">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 2v4m0 12v4m10-10h-4M6 12H2"/>
            </svg>
          </button>
        </div>
        <div id="locationStatus"></div>
      </div>

      <!-- Drive Time -->
      <div class="card">
        <h2>Max Drive Time</h2>
        <div class="slider-row">
          <input type="range" id="driveTime" min="5" max="30" step="5" value="15" />
          <span class="slider-value" id="driveTimeValue">15 min</span>
        </div>
        <div class="drive-time-legend" id="driveTimeLegend" style="display:none;">
          <span class="swatch"></span> Reachable drive-time area
        </div>
      </div>

      <!-- Compare Button -->
      <button class="btn btn-primary btn-compare" id="compareBtn">Compare Prices</button>
    </div>

    <!-- Main content -->
    <div class="main">
      <div id="map"></div>
      <div id="results">
        <div class="empty-state">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 100 4 2 2 0 000-4z"/>
          </svg>
          <p>Add items to your list and click <strong>Compare Prices</strong><br>to find the best deals nearby.</p>
        </div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet-geocoder@3.1.4/dist/esri-leaflet-geocoder.js"></script>
  <script>
    // =========================================================
    // State
    // =========================================================
    let shoppingList = [];
    let storeData = null;
    let userLocation = { lat: 40.744, lng: -74.032, label: "Hoboken, NJ" };
    let map, userMarker, storeMarkers = [];
    let driveTimePolygon = null;
    let searchControl = null;

    function getApiKey() {
      return document.getElementById("apiKeyInput").value.trim();
    }

    // =========================================================
    // Load mock data
    // =========================================================
    async function loadData() {
      const res = await fetch("data/mock-prices.json");
      storeData = await res.json();
      renderQuickAdd();
    }

    // =========================================================
    // Map — Esri basemap via esri-leaflet
    // =========================================================
    function initMap() {
      map = L.map("map").setView([userLocation.lat, userLocation.lng], 13);

      // Esri basemap tile layer (World Street Map)
      L.esri.basemapLayer("Streets").addTo(map);

      userMarker = L.marker([userLocation.lat, userLocation.lng], {
        icon: L.divIcon({
          className: "",
          html: '<div style="width:14px;height:14px;background:#2563eb;border:3px solid #fff;border-radius:50%;box-shadow:0 1px 4px rgba(0,0,0,.3)"></div>',
          iconSize: [14, 14],
          iconAnchor: [7, 7]
        })
      }).addTo(map).bindPopup("You");

      // Esri geocoder search control on the map
      searchControl = L.esri.Geocoding.geosearch({
        position: "topright",
        placeholder: "Search address...",
        useMapBounds: false,
        providers: [
          L.esri.Geocoding.arcgisOnlineProvider({
            apikey: getApiKey() || undefined
          })
        ]
      }).addTo(map);

      // When user selects a search result from the map control, update location
      searchControl.on("results", function (data) {
        if (data.results && data.results.length > 0) {
          const r = data.results[0];
          userLocation = { lat: r.latlng.lat, lng: r.latlng.lng };
          locationInput.value = r.text || r.properties.LongLabel || "";
          userMarker.setLatLng([userLocation.lat, userLocation.lng]);
          locationStatus.textContent = "Location set from map search";
          locationStatus.className = "location-status";
        }
      });
    }

    function clearStoreMarkers() {
      storeMarkers.forEach(m => map.removeLayer(m));
      storeMarkers = [];
    }

    function clearDriveTimePolygon() {
      if (driveTimePolygon) {
        map.removeLayer(driveTimePolygon);
        driveTimePolygon = null;
      }
    }

    function addStoreMarker(store, rank, total) {
      const colors = ["#16a34a", "#ea580c", "#dc2626", "#6b7280", "#6b7280", "#6b7280"];
      const color = colors[Math.min(rank, colors.length - 1)];
      const marker = L.marker([store.lat, store.lng], {
        icon: L.divIcon({
          className: "",
          html: `<div style="
            background:${color};color:#fff;font-weight:700;font-size:12px;
            width:28px;height:28px;border-radius:50%;
            display:flex;align-items:center;justify-content:center;
            border:2px solid #fff;box-shadow:0 1px 4px rgba(0,0,0,.3);
          ">${rank + 1}</div>`,
          iconSize: [28, 28],
          iconAnchor: [14, 14]
        })
      }).addTo(map);
      marker.bindPopup(`<strong>${store.name}</strong><br>${store.address}<br>Total: $${total.toFixed(2)}`);
      storeMarkers.push(marker);
    }

    // =========================================================
    // Esri Geocoding — resolve address text to lat/lng
    // =========================================================
    async function geocodeWithEsri(text) {
      const apikey = getApiKey();
      const params = new URLSearchParams({
        f: "json",
        singleLine: text,
        maxLocations: 1,
        outFields: "Match_addr"
      });
      if (apikey) params.set("token", apikey);

      const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?${params}`;
      const res = await fetch(url);
      const data = await res.json();

      if (data.candidates && data.candidates.length > 0) {
        const c = data.candidates[0];
        return { lat: c.location.y, lng: c.location.x, label: c.attributes.Match_addr };
      }
      return null;
    }

    // =========================================================
    // Esri Service Area — drive-time polygon
    // =========================================================
    async function fetchDriveTimePolygon(lat, lng, minutes) {
      const apikey = getApiKey();
      if (!apikey) return null;

      const params = new URLSearchParams({
        f: "json",
        token: apikey,
        facilities: `${lng},${lat}`,
        defaultBreaks: String(minutes),
        travelDirection: "esriNATravelDirectionFromFacility",
        outputPolygons: "esriServiceAreaPolygonSimplified",
        travelMode: '{"type":"automobile"}',
        trimOuterPolygon: "true"
      });

      const url = `https://route.arcgis.com/arcgis/rest/services/World/ServiceAreas/NAServer/ServiceArea_World/solveServiceArea?${params}`;

      try {
        const res = await fetch(url);
        const data = await res.json();

        if (data.saPolygons && data.saPolygons.features && data.saPolygons.features.length > 0) {
          const rings = data.saPolygons.features[0].geometry.rings;
          // Convert Esri ring format [lng, lat] to Leaflet [lat, lng]
          const latlngs = rings.map(ring =>
            ring.map(coord => [coord[1], coord[0]])
          );
          return latlngs;
        }
      } catch (e) {
        console.warn("Service area request failed:", e);
      }
      return null;
    }

    // =========================================================
    // Fallback: Haversine distance / drive-time estimation
    // =========================================================
    function haversineKm(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function estimateDriveMinutes(lat1, lng1, lat2, lng2) {
      const km = haversineKm(lat1, lng1, lat2, lng2);
      return (km / 25) * 60; // ~25 km/h urban average
    }

    function formatDistance(lat1, lng1, lat2, lng2) {
      const km = haversineKm(lat1, lng1, lat2, lng2);
      const miles = km * 0.621371;
      const mins = Math.round(estimateDriveMinutes(lat1, lng1, lat2, lng2));
      return `${miles.toFixed(1)} mi · ~${mins} min`;
    }

    // Point-in-polygon test (ray casting) for drive-time polygon filtering
    function pointInPolygon(lat, lng, polygonRings) {
      for (const ring of polygonRings) {
        let inside = false;
        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const yi = ring[i][0], xi = ring[i][1];
          const yj = ring[j][0], xj = ring[j][1];
          if (((yi > lat) !== (yj > lat)) && (lng < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
            inside = !inside;
          }
        }
        if (inside) return true;
      }
      return false;
    }

    // =========================================================
    // Shopping list UI — lined paper
    // =========================================================
    const linedPaper = document.getElementById("linedPaper");
    const suggestionsList = document.getElementById("suggestionsList");
    const VISIBLE_LINES = 12;
    let activeLineIndex = null;

    function syncShoppingList() {
      shoppingList = [];
      linedPaper.querySelectorAll(".lined-paper-line input").forEach(input => {
        const val = input.value.trim().toLowerCase();
        if (val) shoppingList.push(val);
      });
    }

    function renderLinedPaper() {
      const totalLines = Math.max(VISIBLE_LINES, shoppingList.length + 3);
      linedPaper.innerHTML = "";
      for (let i = 0; i < totalLines; i++) {
        const line = document.createElement("div");
        line.className = "lined-paper-line" + (i >= shoppingList.length ? " empty" : "");
        const input = document.createElement("input");
        input.type = "text";
        input.value = shoppingList[i] || "";
        input.placeholder = i === 0 && shoppingList.length === 0 ? "Type an item..." : "";
        input.autocomplete = "off";
        input.dataset.line = i;
        input.addEventListener("input", handleLineInput);
        input.addEventListener("keydown", handleLineKeydown);
        input.addEventListener("focus", handleLineFocus);
        input.addEventListener("blur", handleLineBlur);
        line.appendChild(input);
        linedPaper.appendChild(line);
      }
    }

    function handleLineInput(e) {
      const input = e.target;
      const line = input.closest(".lined-paper-line");
      const val = input.value.trim();
      if (val) {
        line.classList.remove("empty");
      } else {
        line.classList.add("empty");
      }
      showSuggestionsForLine(input);
      syncShoppingList();
    }

    function handleLineKeydown(e) {
      const idx = parseInt(e.target.dataset.line);
      if (e.key === "Enter") {
        e.preventDefault();
        // Move to next line, adding one if needed
        const nextIdx = idx + 1;
        const lines = linedPaper.querySelectorAll(".lined-paper-line input");
        if (nextIdx < lines.length) {
          lines[nextIdx].focus();
        }
        hideSuggestions();
      } else if (e.key === "Backspace" && e.target.value === "" && idx > 0) {
        e.preventDefault();
        // Remove this empty line and move up
        const lines = Array.from(linedPaper.querySelectorAll(".lined-paper-line"));
        if (lines.length > VISIBLE_LINES) {
          lines[idx].remove();
          // Re-index
          linedPaper.querySelectorAll(".lined-paper-line input").forEach((inp, i) => {
            inp.dataset.line = i;
          });
        }
        const prevLines = linedPaper.querySelectorAll(".lined-paper-line input");
        if (prevLines[idx - 1]) prevLines[idx - 1].focus();
        syncShoppingList();
      } else if (e.key === "ArrowDown") {
        const lines = linedPaper.querySelectorAll(".lined-paper-line input");
        if (idx + 1 < lines.length) { e.preventDefault(); lines[idx + 1].focus(); }
      } else if (e.key === "ArrowUp") {
        const lines = linedPaper.querySelectorAll(".lined-paper-line input");
        if (idx - 1 >= 0) { e.preventDefault(); lines[idx - 1].focus(); }
      }
    }

    function handleLineFocus(e) {
      activeLineIndex = parseInt(e.target.dataset.line);
      showSuggestionsForLine(e.target);
    }

    function handleLineBlur() {
      setTimeout(() => {
        activeLineIndex = null;
        hideSuggestions();
      }, 150);
    }

    function showSuggestionsForLine(input) {
      const val = input.value.trim().toLowerCase();
      if (!val || !storeData) { hideSuggestions(); return; }
      const matches = storeData.availableItems.filter(
        item => item.includes(val) && !shoppingList.includes(item)
      );
      if (matches.length === 0) { hideSuggestions(); return; }
      suggestionsList.innerHTML = matches.map(m =>
        `<div onclick="fillLine('${m}')">${m}</div>`
      ).join("");
      suggestionsList.classList.add("visible");
    }

    function fillLine(value) {
      if (activeLineIndex === null) return;
      const inputs = linedPaper.querySelectorAll(".lined-paper-line input");
      if (inputs[activeLineIndex]) {
        inputs[activeLineIndex].value = value;
        inputs[activeLineIndex].closest(".lined-paper-line").classList.remove("empty");
        syncShoppingList();
        // Move to next line
        const next = activeLineIndex + 1;
        if (inputs[next]) inputs[next].focus();
      }
      hideSuggestions();
    }

    function addItem(name) {
      const clean = name.trim().toLowerCase();
      if (!clean || shoppingList.includes(clean)) return;
      shoppingList.push(clean);
      renderLinedPaper();
    }

    function removeItem(index) {
      shoppingList.splice(index, 1);
      renderLinedPaper();
    }

    function hideSuggestions() {
      suggestionsList.classList.remove("visible");
    }

    document.addEventListener("click", e => {
      if (!e.target.closest(".shopping-list-card")) hideSuggestions();
    });

    function renderQuickAdd() {
      const popular = ["milk", "eggs", "bread", "bananas", "chicken breast", "rice", "coffee"];
      const quickAddEl = document.getElementById("quickAdd");
      quickAddEl.innerHTML = popular.map(item =>
        `<button onclick="addItem('${item}')">${item}</button>`
      ).join("");
      renderLinedPaper();
    }

    // =========================================================
    // Drive-time slider
    // =========================================================
    const driveTimeSlider = document.getElementById("driveTime");
    const driveTimeValue = document.getElementById("driveTimeValue");
    driveTimeSlider.addEventListener("input", () => {
      driveTimeValue.textContent = driveTimeSlider.value + " min";
    });

    // =========================================================
    // API key status
    // =========================================================
    const apiKeyInput = document.getElementById("apiKeyInput");
    const apiKeyStatusEl = document.getElementById("apiKeyStatus");
    const driveTimeLegend = document.getElementById("driveTimeLegend");

    apiKeyInput.addEventListener("input", () => {
      const key = getApiKey();
      if (key.length > 10) {
        apiKeyStatusEl.textContent = "Key set — geocoding and drive-time areas enabled";
        apiKeyStatusEl.className = "api-key-status valid";
      } else {
        apiKeyStatusEl.textContent = "No key — using basic mode (haversine estimates)";
        apiKeyStatusEl.className = "api-key-status missing";
      }
    });

    // =========================================================
    // Geolocation
    // =========================================================
    const geoBtn = document.getElementById("geoBtn");
    const locationInput = document.getElementById("locationInput");
    const locationStatus = document.getElementById("locationStatus");

    geoBtn.addEventListener("click", () => {
      if (!navigator.geolocation) {
        locationStatus.textContent = "Geolocation not supported";
        locationStatus.className = "location-status error";
        return;
      }
      locationStatus.textContent = "Getting location...";
      locationStatus.className = "location-status";
      navigator.geolocation.getCurrentPosition(
        async pos => {
          userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          locationInput.value = `${pos.coords.latitude.toFixed(4)}, ${pos.coords.longitude.toFixed(4)}`;

          // Reverse-geocode with Esri to get a readable address
          const apikey = getApiKey();
          if (apikey) {
            try {
              const params = new URLSearchParams({
                f: "json",
                token: apikey,
                location: `${pos.coords.longitude},${pos.coords.latitude}`
              });
              const res = await fetch(`https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?${params}`);
              const data = await res.json();
              if (data.address) {
                locationInput.value = data.address.Match_addr || data.address.LongLabel || locationInput.value;
              }
            } catch (e) {
              // Keep coordinate display as fallback
            }
          }

          locationStatus.textContent = "Location set";
          locationStatus.className = "location-status";
          map.setView([userLocation.lat, userLocation.lng], 13);
          userMarker.setLatLng([userLocation.lat, userLocation.lng]);
        },
        err => {
          locationStatus.textContent = "Could not get location";
          locationStatus.className = "location-status error";
        }
      );
    });

    // =========================================================
    // Compare logic
    // =========================================================
    const compareBtn = document.getElementById("compareBtn");
    const resultsEl = document.getElementById("results");

    compareBtn.addEventListener("click", runComparison);

    async function runComparison() {
      if (shoppingList.length === 0) {
        resultsEl.innerHTML = '<div class="card" style="padding:20px;color:var(--red);">Please add at least one item to your list.</div>';
        return;
      }

      compareBtn.disabled = true;
      compareBtn.textContent = "Searching...";

      // Geocode the location using Esri (or fall back to coordinates)
      let loc = null;
      const inputVal = locationInput.value.trim();

      // Check if input looks like raw coordinates
      const coordMatch = inputVal.match(/^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/);
      if (coordMatch) {
        loc = { lat: parseFloat(coordMatch[1]), lng: parseFloat(coordMatch[2]) };
      } else {
        // Use Esri geocoding
        const esriResult = await geocodeWithEsri(inputVal);
        if (esriResult) {
          loc = esriResult;
          locationStatus.textContent = `Resolved: ${esriResult.label}`;
          locationStatus.className = "location-status";
        }
      }

      if (!loc) {
        // Fallback to default
        loc = { lat: 40.744, lng: -74.032 };
        locationStatus.textContent = "Could not geocode — using default (Hoboken)";
        locationStatus.className = "location-status error";
      }

      userLocation = loc;
      map.setView([loc.lat, loc.lng], 13);
      userMarker.setLatLng([loc.lat, loc.lng]);

      const maxMinutes = parseInt(driveTimeSlider.value);

      // Try to fetch Esri drive-time polygon
      clearDriveTimePolygon();
      let driveTimeRings = null;
      const apikey = getApiKey();

      if (apikey) {
        driveTimeRings = await fetchDriveTimePolygon(loc.lat, loc.lng, maxMinutes);
        if (driveTimeRings) {
          driveTimePolygon = L.polygon(driveTimeRings, {
            color: "rgba(37, 99, 235, 0.5)",
            fillColor: "rgba(37, 99, 235, 0.08)",
            weight: 2,
            dashArray: "6 4"
          }).addTo(map);
          driveTimeLegend.style.display = "flex";
        }
      }

      if (!driveTimeRings) {
        driveTimeLegend.style.display = "none";
      }

      // Filter stores: use polygon if available, otherwise haversine estimate
      const reachableStores = storeData.stores.filter(store => {
        if (driveTimeRings) {
          return pointInPolygon(store.lat, store.lng, driveTimeRings);
        }
        return estimateDriveMinutes(loc.lat, loc.lng, store.lat, store.lng) <= maxMinutes;
      });

      if (reachableStores.length === 0) {
        clearStoreMarkers();
        resultsEl.innerHTML = '<div class="card" style="padding:20px;color:var(--orange);">No stores found within your drive time. Try increasing the range.</div>';
        compareBtn.disabled = false;
        compareBtn.textContent = "Compare Prices";
        return;
      }

      // Calculate totals
      const storeResults = reachableStores.map(store => {
        let total = 0;
        let itemCount = 0;
        const prices = {};
        shoppingList.forEach(item => {
          if (store.prices[item] !== undefined) {
            prices[item] = store.prices[item];
            total += store.prices[item];
            itemCount++;
          } else {
            prices[item] = null;
          }
        });
        return { store, prices, total, itemCount };
      });

      storeResults.sort((a, b) => a.total - b.total);

      // Find cheapest / most expensive per item
      const cheapestPerItem = {};
      const mostExpensivePerItem = {};
      shoppingList.forEach(item => {
        let min = Infinity, max = -Infinity;
        storeResults.forEach(sr => {
          if (sr.prices[item] !== null) {
            if (sr.prices[item] < min) min = sr.prices[item];
            if (sr.prices[item] > max) max = sr.prices[item];
          }
        });
        cheapestPerItem[item] = min === Infinity ? null : min;
        mostExpensivePerItem[item] = max === -Infinity ? null : max;
      });

      // Update map markers
      clearStoreMarkers();
      const bounds = L.latLngBounds([[loc.lat, loc.lng]]);
      storeResults.forEach((sr, i) => {
        addStoreMarker(sr.store, i, sr.total);
        bounds.extend([sr.store.lat, sr.store.lng]);
      });
      if (driveTimePolygon) {
        bounds.extend(driveTimePolygon.getBounds());
      }
      map.fitBounds(bounds, { padding: [40, 40] });

      // Calculate savings
      const cheapest = storeResults[0];
      const mostExpensive = storeResults[storeResults.length - 1];
      const savings = mostExpensive.total - cheapest.total;

      // Build results HTML
      let html = "";

      if (storeResults.length > 1) {
        html += `
          <div class="savings-banner">
            <div>
              <div class="label">Best option</div>
              <div class="value">${cheapest.store.name} — $${cheapest.total.toFixed(2)}</div>
            </div>
            <div>
              <div class="detail">Save $${savings.toFixed(2)} vs ${mostExpensive.store.name}</div>
              <div class="detail">${formatDistance(loc.lat, loc.lng, cheapest.store.lat, cheapest.store.lng)} drive</div>
            </div>
          </div>
        `;
      }

      html += `<div class="card"><div class="results-table-wrap"><table class="results-table">`;
      html += `<tr><th>Item</th>`;
      storeResults.forEach((sr, i) => {
        const dist = formatDistance(loc.lat, loc.lng, sr.store.lat, sr.store.lng);
        html += `<th class="store-col"><div class="store-header"><span class="store-name">${i + 1}. ${sr.store.name}</span><span class="store-dist">${dist}</span></div></th>`;
      });
      html += `</tr>`;

      shoppingList.forEach(item => {
        html += `<tr><td>${item}</td>`;
        storeResults.forEach(sr => {
          const price = sr.prices[item];
          if (price === null) {
            html += `<td class="no-price">N/A</td>`;
          } else {
            const isCheapest = price === cheapestPerItem[item] && storeResults.length > 1;
            const isExpensive = price === mostExpensivePerItem[item] && storeResults.length > 1 && price !== cheapestPerItem[item];
            const cls = isCheapest ? "cheapest" : isExpensive ? "expensive" : "";
            html += `<td class="${cls}">$${price.toFixed(2)}</td>`;
          }
        });
        html += `</tr>`;
      });

      html += `<tr class="total-row"><td>Total</td>`;
      storeResults.forEach(sr => {
        html += `<td>$${sr.total.toFixed(2)}</td>`;
      });
      html += `</tr>`;
      html += `</table></div></div>`;

      resultsEl.innerHTML = html;
      compareBtn.disabled = false;
      compareBtn.textContent = "Compare Prices";
    }

    // =========================================================
    // Init
    // =========================================================
    loadData().then(() => {
      initMap();
    });
  </script>
</body>
</html>
